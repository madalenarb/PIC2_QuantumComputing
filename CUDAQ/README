# CUDA-Q QFT Simulation & Benchmark Suite üöÄ

A curated set of **CUDA-Q** examples that showcase‚Äîand stress-test‚Äîthe *Quantum Fourier Transform* (QFT) on both **CPU** (`qpp-cpu`) and **GPU** (`nvidia`) back-ends.  
Every script uses NVIDIA‚Äôs CUDA-Q Python API.

---

## 0 ¬∑ Quick start

```bash
# 1) Clone or unzip this repository

# 2) Create & activate the exact env
conda env create -f environment.yml    # creates ‚Äúcuda-quantum‚Äù
conda activate cuda-quantum

# 3) Sanity-check the install
python - <<'PY'
import cudaq
print("CUDA-Q version :", cudaq.__version__)
print("Detected GPUs   :", cudaq.num_available_gpus())
PY
````

> **Tip:**
> For a lean CPU-only setup, remove all `nvidia-*`, `cuda-*` and `cu*` lines from `environment.yml` and recreate the env. CUDA-Q will fall back to its `qpp-cpu` simulator.

---

## 1 ¬∑ Environment overview

| Environment        | Purpose                                                                | Creation command                      |
| ------------------ | ---------------------------------------------------------------------- | ------------------------------------- |
| **`cuda-quantum`** | Full GPU tool-chain: CUDA 11.8, cuQuantum, cuTensor, CUDA-Q + plotting | `conda env create -f environment.yml` |

*All other packages (NumPy, pandas, Matplotlib, seaborn, ‚Ä¶) are pinned in* `environment.yml`.

---

## 2 ¬∑ Script catalogue

|  #  | Script                              | Purpose / highlights                                                      |
| :-: | :---------------------------------- | :------------------------------------------------------------------------ |
|  1  | `1_MaximallyEntangled.py`           | Minimal Bell-pair kernel (sanity check)                                   |
|  2  | `qft3.py`                           | 3‚Äì5 qubit GHZ‚ÜíQFT state-vector demo + fidelity                            |
|  3  | `qft3_noise_model.py`               | Interactive 3-qubit QFT with selectable noise model                       |
|  4  | `qft4.py`                           | 4-qubit GHZ‚ÜíQFT + histogram CSV/PNG export                                |
|  5  | `qftN.py`                           | Quick arbitrary-size QFT experiment                                       |
|  6  | `benchmark_QFT_multipleshots.py`    | Main benchmark‚ÄîCPU/GPU, sampling or state-vector, single/multi-shot sweep |
|  7  | `benchmark_qftN_cpu_noise_model.py` | CPU density-matrix sweeps over 4 noise channels & probabilities           |
|  8  | `benchmark_qftN_memory_track.py`    | GPU benchmark with live core% & VRAM tracking (requires `pynvml`)         |

---

## 3 ¬∑ Running the examples

### 3.1 ¬∑ Tiny sanity checks

```bash
python 1_MaximallyEntangled.py
python qft3.py
python qft3_noise_model.py
python qft4.py
```

### 3.2 ¬∑ `benchmark_QFT_multipleshots.py`

Benchmarks **sampling** or **state-vector** on CPU/GPU, single or sweep of shot counts.

```bash
# Sampling on GPU, 131 072 shots
python benchmark_QFT_multipleshots.py \
  --target nvidia \
  --init zero     \
  --method sample \
  --shots 131072

# State-vector sweep on CPU (up to 21 qubits)
python benchmark_QFT_multipleshots.py \
  --target qpp-cpu    \
  --init ghz          \
  --method statevector\
  --multi             # ‚áí shots = 2^12‚Ä¶2^19
```

| Flag         | Meaning                                               | Default  |
| ------------ | ----------------------------------------------------- | -------- |
| `--target`   | `qpp-cpu` or `nvidia`                                 | `nvidia` |
| `--init`     | `zero` or `ghz`                                       | `zero`   |
| `--method`   | `sample` or `statevector`                             | `sample` |
| `--max-bits` | Max qubits (GPU 28 / CPU 21)                          | auto     |
| `--shots`    | Single shot count (mutually exclusive with `--multi`) | 131 072  |
| `--multi`    | Sweep shots 2^12‚Ä¶2^19                                 | ‚Äì        |

### 3.3 ¬∑ `benchmark_qftN_cpu_noise_model.py`

Noiseless CPU state-vector baseline, then CPU density-matrix sweeps over 4 noise channels:

```bash
python benchmark_qftN_cpu_noise_model.py \
  --init ghz  --shots 16384 \
  --max-bits 10 \
  --probs 0.01 0.05 0.1
```

Outputs ‚Üí `results/qftN_<init>_<shots>_cpu.csv` with columns for `Fidelity`, `Fro_norm`, `L2_pop`.

### 3.4 ¬∑ `benchmark_qftN_memory_track.py`

GPU-only benchmark that samples `pynvml` every 0.1 s to record average core%, mem% and actual MiB:

```bash
python benchmark_qftN_memory_track.py \
  --shots 4096 \
  --max-bits 27 \
  --out-dir results/GPUmonitored
```

Saves both CSV and XLSX.

---

## 4 ¬∑ Outputs & Cleanup

* All CSVs ‚Üí `results/`
* Histograms & diagrams ‚Üí `results/qft4/`

```bash
rm -rf results qft4
```

---

## 5 ¬∑ Notes & Best Practices

* **Warm-up** each kernel with 32 dummy shots (scripts do this automatically).
* If you hit `RuntimeError: requested size is too big`, lower `--max-bits` or switch to sampling.
* **Statevector** simulation requires `cudaq >= 0.9.1` (for `cudaq.simulate()`).
* Env uses CUDA 11.8; adjust if your driver is older.
* Matplotlib runs headless‚Äîno display needed (ideal for SSH).

Happy benchmarking! üöÄ

